"""
This script loops through each row of a dataset and applies cleaning operations
to each row based on the configuration file that was auto-generated by the
config_builder.py script.
"""

# Import rules.py from the normalizer module
# Include pandas for pd.isna()
# Include typing for backward compatibility
from normalizer import rules
import pandas as pd 
from typing import Tuple, Dict

##################################################

"""
Define the function to clean a single row of data. This function takes a row 
as a dictionary plus the YAML configuration and returns a new, cleaned dictionary
with the same keys but transformed values.  It also produces a second dictionary
with the changes, to enable logging and analysis of the cleaning process.
"""
def clean_row(row: dict, config: dict) -> tuple[dict, dict]:
    # Initialize an empty dictionary to hold cleaned values
    cleaned = {}
    
    # Initialize a dictionary to hold changes for logging
    changes = {}
    
    # Reads the field_rules from the YAML config as a dictionary
    field_rules = config.get("field_rules", {})
    
    # Loop through each key-value pair in the row and apply cleaning rules
    for key, val in row.items():
        original_val = val
        changed = False  # Track if this field was modified
        rules_for_field = field_rules.get(key, {})

        # Skip the field if marked to be ignored
        if rules_for_field.get("ignore", False):
            cleaned[key] = val
            continue

        # Apply transformations conditionally based on the rules defined
        # First transformation is replacing nulls if configured
        null_cfg = rules_for_field.get("replace_nulls_with")
        if pd.isna(val) and isinstance(null_cfg, dict) and null_cfg.get("enabled"):
            val = null_cfg.get("value", "Not Specified")

         # Second transformation is trimming whitespace
        if rules_for_field.get("trim_whitespace", False):
            val = rules.strip_whitespace(val)

        # Third transformation is converting to specified case
        normalize_case = rules_for_field.get("normalize_case")
        if normalize_case and normalize_case is not False:
            val = rules.normalize_case(val, normalize_case)

        # Fourth transformation is removing invalid characters
        if rules_for_field.get("remove_invalid_chars", False):
            val = rules.remove_invalid_chars(val)

        # Fifth transformation is fixing date formats
        fix_date_cfg = rules_for_field.get("fix_date_format")
        if isinstance(fix_date_cfg, dict):
            input_fmt = fix_date_cfg.get("input_format", "%m/%d/%Y")
            output_fmt = fix_date_cfg.get("output_format", "%Y-%m-%d")
            val = rules.fix_date_format(val, input_format=input_fmt, output_format=output_fmt)

        # Determine the changes to log to the changes dictionary
        if val != original_val:
            changes[key] = {
                "from": original_val,
                "to": val
            }

        # Save the cleaned value back to the cleaned dictionary
        cleaned[key] = val

    # Return the cleaned dictionary and changes dictionary with all transformations applied
    return cleaned, changes

##################################################